# Intents Flow with ERC-7683 and ZK Proof of Finality

This project will develop a PoC of cross-chain intent address between 3 chains illustrating the flow of:
* The **User** simply signs a single message and funds an ephemeral address with the desired token.
* The **Filler** validates user’s signed order, deploys ephemeral contracts on source and destination chains, completes bridging, obtains finality proof, and submits proof to unlock escrow and recover fees.

Key background:
* [Cross L2 with Intent Addresses](https://www.youtube.com/watch?v=ioCdBWLmuI8) describes how to use CREATE2 for deterministic ephemeral intent addresses generated by a user, but deployed by fillers that "sponsor the gas".
* [Unifying Ethereum Through Intents and ERC-7683](https://www.youtube.com/watch?v=jjBxfIsTrLE)
describes [ERC7683](https://www.erc7683.org/spec), using `GaslessCrossChainOrder` to represent off-chain user intent.
* [SP1 Groth proof of finality](https://hackmd.io/F5iI9RfQQoCSFCgXbUalKg) describes how to generate the proof

The solution has all desirable properties:

- **Trust Minimization**: The filler cannot prematurely unlock the user’s tokens on the source chain, because the ephemeral contract checks for a valid SP1 finality proof.  
- **Gasless for the User**: The filler pays gas on both chains, recouping costs via a fee.  
- **Replay Protection + Deterministic Addressing**: `CREATE2` ensures each ephemeral contract is predictable and unique per user intent. Salt/nonce logic protects against replay.  
- **Composability**: Because ephemeral contracts follow the ERC-7683 interface, multiple fillers can compete to fill orders, potentially offering better prices and efficiency.

## User Flow

1. **User Creates an Off-Chain Intent (GaslessCrossChainOrder)**  
   - The user constructs (off-chain) a data structure conforming to [ERC-7683](https://eips.ethereum.org/EIPS/eip-7683) (e.g. `GaslessCrossChainOrder`) that specifies:  
     - Source chain and destination chain.  
     - Token to bridge (e.g. USDT).  
     - Amount (e.g. 5 USDT).  
     - Salt/Nonce (for replay protection).  
     - The ephemeral “intent” address that will be used on both chains (computed deterministically using `CREATE2`).  
     - Additional parameters like fill fees, expiration time, etc. (to protect the user from indefinite locking of tokens).  
   - The user then **signs** this intent with their private key.
   - The user (or user’s UI) calls the `IntentFactory` (on each chain) to compute the ephemeral address (using the same salt).  
   - Under the hood, the ephemeral address is derived from something like:
     ```solidity
     ephemeralAddress = CREATE2(
       factoryAddress, 
       userSalt, 
       keccak256(ContractBytecode)
     )
     ```
   - **Important**: The ephemeral contract is *not yet deployed* at this point, but we already know what the address *will* be once deployed.

2. **User Transfers Tokens to the Ephemeral Address on the Source Chain**  
   - On the source chain, the user transfers the desired amount of the ERC20 token (e.g. 5 USDT) to the **ephemeral address**.  
   - Because the address is already known (deterministically computed with CREATE2), the user can send tokens to it *before* the contract is deployed.  
   - These tokens now appear on-chain as “owned” by that address, although no actual code is deployed yet.

3. **User Waits for a Filler to Pick Up the Intent**  
   - From the user’s perspective, once they have transferred the tokens to the ephemeral address and published/signed their off-chain order (`GaslessCrossChainOrder`), they are done.  
   - The next steps (deploying ephemeral contracts, bridging, finality proof submission) are handled by **Fillers** (a third-party or aggregator who sponsors gas).  A **Filler** sees the user’s intent, checks that the ephemeral address is funded, and executes the bridging steps on both chains. They are incentivized by fees or other compensation in the user’s `GaslessCrossChainOrder`.
   - The filler (e.g. a specialized service or aggregator) receives the signed `GaslessCrossChainOrder`.  
   - The filler verifies the user signature and checks that the ephemeral address on the source chain is funded with the correct amount of tokens.
   - Since the ephemeral address is precomputed via `CREATE2`, the filler can trigger `IntentFactory.deploy(...)` with the same salt and bytecode.  
   - Now the ephemeral address becomes a **real** on-chain contract with code.  
   - **Inside this ephemeral contract** is logic that:  
     - Holds the user’s tokens in escrow.  
     - Will release them to the filler if/when a valid SP1 Groth16 finality proof is submitted (proving the destination chain transfer was finalized).

4. **Filler Executes Bridging to the Destination Chain**  
   - On the destination chain (e.g. Sepolia), the filler also deploys the **same ephemeral contract** (same salt, same bytecode) via `IntentFactory`.  
   - The ephemeral contract on the destination chain handles receiving (or minting) the bridged tokens.  
   - The user’s bridging request is thus fulfilled on the destination chain. The tokens can be in the ephemeral contract or directly transferred to the user’s address.

5. **User Receives Tokens on the Destination Chain**  
   - The ephemeral contract on the destination chain will release (or directly transfer) the bridged tokens (or their equivalent) to the user’s address.  
   - If everything goes as intended, the user does not have to directly pay gas on *either* chain (the filler sponsors gas).

6. **Filler Waits for Destination Finality + Generates SP1 Proof**  
   - After bridging on the destination chain, the filler waits for finality.  
     - that the L2 chain has updated the storage value of the ephemeral contract (e.g. destinationFulfilled=1)
     - that the L2 state root is correct   
   - The filler then generates or obtains an **SP1 Groth16 finality proof**, which is cryptographic evidence that the destination chain has finalized the bridging transaction.

7. **Filler Submits the Finality Proof to the Source Chain**  
   - The filler calls a function (e.g. `unlockEscrow()`) on the ephemeral contract deployed on the source chain, providing:  
     - The SP1 proof.  
     - Public inputs (like block number, state root, etc.).  
     - Other data required for on-chain verification.  
   - The ephemeral contract verifies the proof using the on-chain SP1 verifier contract.
   - Upon successful proof verification, the ephemeral contract **unlocks** the user’s tokens that were in escrow.  
   - Typically, these tokens go to the filler (or partially to the filler as a fee), compensating them for sponsoring gas.


## Setup 

This repo will have the smart contracts.  A separate repo have a UI for users to submit their intent and observe their fill execution, and another UI to observe the filler network.


Install dependencies:

```
cd intent
npm install
```

Initialize Hardhat, start a local Hardhat node:

```
npx hardhat init
npx hardhat node
```

Deploy the `IntentFactory`:

```
npx hardhat run scripts/1_deployFactory.js --network localhost
```

Copy the address printed by the script (the IntentFactory deployment address).

Edit scripts/demo.js and replace:

```
const factoryAddress = "<INTENT_FACTORY_ADDRESS>";
```

Run the demo:

```
npx hardhat run scripts/demo.js --network localhost
```

You should see console output similar to:

```
MOCK deployed at: 0x...
Ephemeral address computed: 0x...
User transferred 100000000000000000000 MOCK to ephemeral address
Deployed ephemeral contract at: 0x...
Ephemeral contract token balance: 100000000000000000000 MOCK
Destination finalized.  
SP1 Proof generated.
Escrow unlocked.
Filler's token balance: 100000000000000000000
```

# Next Steps

The above flow:

1. Needs to work as described across at least 3 chains in Testnet and then production:
   - OP Stack Rollup (Chain ID 357): [RPC](https://rpc-jam-ccw030wxbz.t.conduit.xyz/Pwe4skpfPaM8HSTPwHDhXzoJoKqdpjfRQ) | [Block explorer](https://explorer-jam-ccw030wxbz.t.conduit.xyz)
   - Ink Sepolia (Chain ID 763373) [RPC](https://rpc-gel-sepolia.inkonchain.com) | [Block explorer](https://explorer-sepolia.inkonchain.com) | [docs](https://blog.kraken.com/product/ink-testnet)
   - Sepolia (Chain ID 11155111) [RPC]() | [Block explorer](https://sepolia.etherscan.io/) 
   - Production: Ethereum | [Ink](https://usdt0.to/) | [Worldcoin](https://world.org/blog/announcements/introducing-world-chain)
2. Needs to include real user signature generation + verification, robust replay protection, fill fees, and timeout handling of `GaslessCrossChainOrder` conformant to ERC7683; use USDT for ERC20 as the assumed token and ETH for gas fee token.
3. Need to have [SP1 Groth16 proof verification](https://sepolia.etherscan.io/address/0x397A5f7f3dBd538f23DE225B51f532c34448dA9B#code) ([docs](https://docs.succinct.xyz/docs/verification/onchain/solidity-sdk)) on all 3 chains.  Stub it out with verifierKey, publicValues and proof, using data from [here](https://dune.com/sourabhniyogi/opsuccinct) and ensure your deployment has SP1 verifier contract on both chains.

Fork this repo and submit a PR with the deployed contracts and a set of ephemeral contracts on source and destination chain with the above properties.